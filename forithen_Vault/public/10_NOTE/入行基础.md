# Application简介
![[Pasted image 20260207225148.png]]
## 关于HOST
**HOST 指的是整台服务器本体，也就是应用运行所依附的最底层环境**，通常包含操作系统（如 Linux 或 Windows Server）、网络配置、文件系统、进程管理、内存与 CPU 等基础资源。HOST 本身不承担具体业务逻辑，它的职责是提供一个可以运行中间件和应用程序的基础平台，因此图中 Tomcat 和 WAR 都是作为“进程”运行在 HOST 提供的环境之上。从分层角度看，HOST 属于基盘层（インフラ／基盤），负责端口监听能力、IP 通信、磁盘读写、进程调度、系统日志等最底层功能；如果这一层出现问题，通常表现为服务器无法登录、端口无法连接、磁盘满、CPU 飙高、进程被杀、系统服务未启动等现象。在日本 IT 现场中，当人们说“Host 側の問題”“Host は正常”“Host にログインして確認する”时，指的就是这一整台服务器级别的环境，而不是具体的应用或中间件，因此 Host 可以理解为承载 Tomcat 和 WAR 的“操作系统级运行容器”，是一切应用运行的基础。
### 和云端HOST的区别
在传统架构里，**Host** 通常指的是一台“具体存在的服务器”，可以是机房里的物理机，也可以是公司内部的一台虚拟机。这台 Host 有固定的硬件资源（CPU、内存、磁盘），固定的 IP，固定的操作系统，由运维人员负责安装系统、打补丁、扩容硬盘、处理故障等。应用（如 Tomcat + WAR）就是部署在这台具体的 Host 上运行的，一旦这台机器坏了、磁盘满了、CPU 不够了，就必须人工处理或更换服务器。

而**云端（Cloud）**的本质，是把“Host 这件事”抽象成一种可以按需获取的资源，不再关心具体是哪一台机器在运行你的系统。你在云上创建的 EC2、VM、Container，本质上也是运行在某一台物理 Host 上，但这个 Host 对你是“不可见的”，由云厂商（AWS、Azure、GCP 等）统一管理。

可以从几个核心角度理解两者的区别：

**1. 是否关心“具体那台机器”**  
传统 Host：

- 是一台明确存在的服务器
    
- 有编号、机架位置、固定配置
    
- 出问题要登录这台机器处理
    

云端：

- 你只看到一个“实例”或“服务”
    
- 不关心它背后是哪台物理机
    
- 故障时可以直接销毁重建实例
    

**2. 资源获取方式**  
传统 Host：

- 先采购服务器
    
- 上架、装系统、配置网络
    
- 才能部署应用
    

云端：

- 几分钟创建一台实例
    
- 用完就可以删除
    
- 按时间或流量计费
    

**3. 扩容方式**  
传统 Host：

- CPU 不够 → 换服务器
    
- 磁盘不够 → 加硬盘
    
- 通常需要停机或人工操作
    

云端：

- 直接修改实例规格（如 t3 → r6i）
    
- 或新增实例做负载均衡
    
- 可以自动扩缩容
    

**4. 运维责任划分**  
传统 Host：

- 公司自己负责硬件、机房、电力、网络
    
- 自己处理硬盘坏、风扇坏等问题
    

云端：

- 云厂商负责物理 Host 和机房
    
- 你只负责系统和应用

## 关于Tomcat
**Tomcat 所在的层级可以理解为“应用服务器层”**，它位于操作系统之上、应用（WAR 包）之下，起到“运行 Java Web 应用的容器”的作用。

可以按层级顺序来理解：

**1. Host（主机层）**  
最底层是 Host，也就是服务器本身（物理机或云上的虚拟机）。  
它提供 CPU、内存、磁盘、网络等硬件资源，并运行操作系统。

**2. OS（操作系统层）**  
在 Host 上运行的是操作系统，比如 Linux 或 Windows Server。  
操作系统负责文件系统、进程管理、网络通信等基础能力。

**3. Tomcat（应用服务器层）**  
Tomcat 就运行在操作系统之上，是一个 **Java Web 应用的运行容器**。

它的核心作用可以用一句话概括：

> Tomcat 是一个专门用来“接收 HTTP 请求并调用 Java 程序处理”的服务器。

它主要做三件事：

- 监听端口（如 8080）
    
- 接收浏览器或系统发来的 HTTP 请求
    
- 把请求交给内部的 Java 程序（Servlet、Controller 等）处理
    
- 把处理结果再通过 HTTP 返回给客户端
    

所以它本质上是一个：

> **Web Server + Java 应用容器**

## 关于 WAR
在 Tomcat 里面运行的，就是你的应用，也就是图中的 **WAR 文件**。

WAR（Web Application Archive）本质上是一个压缩包，里面包含：

- Java 代码（编译后的 class）
    
- 配置文件
    
- 前端资源（HTML、CSS、JS）
    
- 第三方依赖库
    

Tomcat 启动时，会：

1. 读取 WAR 文件
    
2. 解压并加载应用
    
3. 把这个应用挂在某个 URL 路径下
    
4. 开始对外提供服务

# 关于 shell 以及 log等
在 IT 系统中，无论是：

- 查看 log
    
- 重启服务
    
- 查看文件
    
- 执行批处理
    
- 调查异常
    

这些操作**最终都是在服务器的操作系统上完成的**。

因为系统结构是这样的：
```
应用（App / WAR）
   ↓
应用服务器（Tomcat / JBoss）
   ↓
操作系统（Linux / Windows）
   ↓
Host（物理机或云服务器）

```
所以：

> 应用运行在服务器上，而服务器本质上是一个操作系统在运行程序。

当我们说：

- “去看 log”
    
- “执行一个 shell”
    
- “跑一个 batch”
    

其实本质上都是：

> 在这台服务器的操作系统里，对文件或进程进行操作。

---

### 二、为什么取 log 本质是 OS 操作

比如你说：

> 用 TeraTerm 连上服务器取 log

实际发生的事情是：

1. 用 TeraTerm 连接到服务器
    
2. 登录到操作系统（Linux 或 Windows）
    
3. 在 OS 的文件系统里找到 log 文件
    
4. 用 OS 命令查看或复制 log
    

比如：

Linux：
```
cd /var/log/app
cat app.log


cd C:\app\log
type app.log

```

所以：

> log 并不是“存在于应用里”，而是“存在于操作系统的文件系统中”。

---

### 三、shell 和 batch 的本质

shell 和 batch 的本质其实是一样的：

> 它们都是操作系统上的“自动化操作脚本”。

只是因为操作系统不同，表现形式不同。
![[Pasted image 20260207230346.png]]
